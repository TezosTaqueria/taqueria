{"mappings":"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","sources":["taqueria-plugin-contract-types/index.ts","taqueria-plugin-contract-types/tasks.ts","taqueria-plugin-contract-types/src/cli-process.ts","taqueria-plugin-contract-types/src/generator/contract-name.ts","taqueria-plugin-contract-types/src/generator/process.ts","taqueria-plugin-contract-types/src/generator/common.ts","taqueria-plugin-contract-types/src/generator/contract-parser.ts","taqueria-plugin-contract-types/src/generator/schema-output.ts","taqueria-plugin-contract-types/src/generator/typescript-output.ts","taqueria-plugin-contract-types/src/type-aliases-file-content.ts","taqueria-plugin-contract-types/src/type-utils-file-content.ts"],"sourcesContent":["import {Plugin, Task, Option} from 'taqueria-sdk'\nimport type { i18n} from 'taqueria-sdk/types'\nimport {tasks} from './tasks'\n\nPlugin.create((i18n: i18n) => ({\n    name: \"contract-types\",\n    schema: \"1.0\",\n    version: \"0.1\",\n    tasks: [\n        Task.create({\n            task: \"types\",\n            command: \"typegen [contract]\",\n            description: \"Generate types for a contract to be used with taquito\",\n            options: [\n                Option.create({\n                    shortFlag: \"o\",\n                    flag: \"typescriptDir\",\n                    description: \"The entry point that will be compiled\"\n                }),\n                Option.create({\n                    shortFlag: \"t\",\n                    flag: \"typeAliasMode\",\n                    choices: ['file', 'simple'],\n                    description: \"The type aliases used in the generated types\"\n                }),\n            ],\n            aliases: [\"types\"],\n            handler: \"proxy\"\n        }),\n    ],\n    proxy: tasks.generateTypes,\n}), process.argv)","import { SanitizedArgs, ActionResponse, Failure, LikeAPromise, ProxyAction } from \"taqueria-sdk/types\";\nimport glob from 'fast-glob'\nimport { join } from 'path'\nimport { generateContractTypesProcessContractFiles } from \"./src/cli-process\";\n\ntype PluginOpts = {\n    // TODO: Document these\n    typescriptDir: string,\n    typeAliasMode?: 'local' | 'file' | 'library' | 'simple',\n};\ntype Opts = SanitizedArgs & Record<string, unknown>;\n\nconst getContractAbspath = (contractFilename: string, parsedArgs: Opts) => \n    join(parsedArgs.artifactsDir, /\\.tz$/.test(contractFilename) ? contractFilename : `${contractFilename}.tz`)\n\n\nconst generateContractTypes = (parsedArgs: Opts & PluginOpts) => async (contractFilename: string) : Promise<string> => {\n    const contractAbspath = getContractAbspath(contractFilename, parsedArgs);\n    await generateContractTypesProcessContractFiles({\n        inputTzContractDirectory: parsedArgs.artifactsDir,\n        inputFiles: [contractAbspath],\n        outputTypescriptDirectory: parsedArgs.typescriptDir,\n        format: 'tz',\n        typeAliasMode: parsedArgs.typeAliasMode ?? 'file',\n    });\n\n    return `${contractFilename}: Types generated`;\n\n    // TODO: Generate contract michelson\n    // TODO: Generate types from michelson\n    \n    // throw new Error('Not Implemented');\n\n    // // TODO: Should getting the default environment be provided by the SDK or the framework?\n    // const currentEnv = parsedArgs.env\n    //     ? (parsedArgs.env as string)\n    //     : (\n    //         parsedArgs.config.environment\n    //             ? parsedArgs.config.environment.default\n    //             : 'development'\n    //     )\n    // const env = parsedArgs.config.environment && parsedArgs.config.environment[currentEnv]\n    //         ? parsedArgs.config.environment[currentEnv]\n    //         : undefined\n            \n    // // Has storage been provided for this contract?\n    // if (env && env.storage) {\n    //     try {\n    //         const tezos = new TezosToolkit(env.rpcUrl)\n    //         const contractData = await readFile(contractAbspath, \"utf-8\")\n\n    //         // TODO: Generate contract michelson\n    //         // TODO: Generate types from michelson\n\n    //         throw new Error('Not Implemented');\n    //         // await importKey(tezos, env.faucet.email, env.faucet.password, env.faucet.mnemonic.join(' '), env.faucet.activation_code)\n    //         // return tezos.contract.originate({\n    //         //     code: contractData,\n    //         //     storage: env.storage[contractFilename]\n    //         // })\n    //         // .then(operation => `${contractFilename}: ${operation.contractAddress}`)\n    //     }\n    //     catch (err) {\n    //         return Promise.reject({\n    //             status: 'failed',\n    //             stdout: \"\",\n    //             stderr: err\n    //         })\n    //     }\n    // }\n\n    // return Promise.reject({\n    //     status: 'failed',\n    //     stderr: `No storage configured in your configuration file for ${contractFilename}`,\n    //     stdout: \"\"\n    // })\n}\n\nconst generateContractTypesAll = (parsedArgs: Opts & PluginOpts) : Promise<string[]> =>\n    glob(\"**/*.tz\", {cwd: parsedArgs.artifactsDir})\n    .then(files => Promise.all(files.map(generateContractTypes(parsedArgs))))\n\nexport const generateTypes = <T>(parsedArgs: Opts): LikeAPromise<ActionResponse, Failure<T>> => {\n    if(!parsedArgs.typescriptDir){\n        return Promise.reject({\n            status: 'failed',\n            stderr: `No typescriptDir configured`,\n            stdout: \"\"\n        });\n    }\n\n    // WORKAROUND: Redirect console.log\n    const strOutLog = [] as string[];\n    const consoleLogOrig = console.log;\n    console.log = (message:string, data?:unknown) => {\n        strOutLog.push(`${message}${data?`\\n${JSON.stringify(data,null,2)}`:''}`);\n    }\n    console.log('generateTypes', { \n        typescriptDir: parsedArgs.typescriptDir\n    });\n\n    // console.log = consoleLogOrig;\n    // return Promise.resolve({\n    //     status: 'success',\n    //     stdout: `${strOutLog.join('\\n')}`,\n    //     stderr: \"\"\n    // });\n\n    const argsTyped = parsedArgs as Opts & PluginOpts;\n\n    const p = argsTyped.contract\n        ? generateContractTypes(argsTyped) (argsTyped.contract as string)\n        : generateContractTypesAll(argsTyped)\n\n    return p.then(data => {\n        console.log = consoleLogOrig;\n        return ({\n            status: 'success',\n            stdout: `${strOutLog.join('\\n')}${Array.isArray(data) ? data.join(\"\\n\") : data}`,\n            stderr: \"\"\n        });\n    })\n}\n\nexport const tasks = {\n    generateTypes,\n} ","import fsRaw from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { normalizeContractName } from './generator/contract-name';\nimport { generateContractTypesFromMichelsonCode } from './generator/process';\nimport { TypeAliasData, TypeUtilsData } from './generator/typescript-output';\nimport { typeAliasesFileContent } from './type-aliases-file-content';\nimport { typeUtilsFileContent } from './type-utils-file-content';\n\nconst fs = {\n    mkdir: promisify(fsRaw.mkdir),\n    copyFile: promisify(fsRaw.copyFile),\n    readdir: promisify(fsRaw.readdir),\n    readFile: promisify(fsRaw.readFile),\n    writeFile: promisify(fsRaw.writeFile),\n    stat: promisify(fsRaw.stat),\n    exists: fsRaw.existsSync,\n};\n\nconst getAllFiles = async (rootPath: string, filter: (fullPath: string) => boolean): Promise<string[]> => {\n    const allFiles = [] as string[];\n\n    const getAllFilesRecursive = async (dirPath: string) => {\n        let files = await fs.readdir(dirPath, { withFileTypes: true });\n\n        for (const f of files) {\n            const subPath = path.resolve(dirPath, f.name);\n\n            if (f.isDirectory()) {\n                await getAllFilesRecursive(subPath);\n                continue;\n            }\n\n            if (!filter(subPath)) {\n                continue;\n            }\n\n            allFiles.push(subPath);\n        }\n    }\n\n    await getAllFilesRecursive(rootPath);\n    return allFiles;\n}\n\nexport const generateContractTypesProcessContractFiles = async ({\n    inputTzContractDirectory,\n    inputFiles,\n    outputTypescriptDirectory,\n    format,\n    typeAliasMode,\n}: {\n    inputTzContractDirectory: string;\n    inputFiles?: string[];\n    outputTypescriptDirectory: string;\n    format: 'tz' | 'json',\n    typeAliasMode: 'local' | 'file' | 'library' | 'simple',\n}): Promise<void> => {\n\n    console.log(`Generating Types: ${path.resolve(inputTzContractDirectory)} => ${path.resolve(outputTypescriptDirectory)}`);\n\n    const ext = '.' + format;\n    const filesAll = await getAllFiles(inputTzContractDirectory, x => x.endsWith(ext));\n    const files = inputFiles ? filesAll.filter(f => inputFiles.some(inputFile => f.endsWith(inputFile))) : filesAll;\n\n    console.log(`Contracts Found: ${[``, ...files].join(`\\n\\t- `)}`);\n\n    const typeAliasImportPath = `@taquito/contract-type-generator`;\n\n    const typeAliasData: TypeAliasData = typeAliasMode === 'local' ? { mode: typeAliasMode, fileContent: typeAliasesFileContent }\n        : typeAliasMode === 'file' ? { mode: typeAliasMode, importPath: `./type-aliases` }\n            : typeAliasMode === 'library' ? { mode: typeAliasMode, importPath: typeAliasImportPath }\n                : { mode: 'simple' };\n\n    if (typeAliasMode === 'file') {\n        // Copy the type alias file\n        await fs.mkdir(outputTypescriptDirectory, { recursive: true });\n        await fs.writeFile(path.join(outputTypescriptDirectory, './type-aliases.ts'), typeAliasesFileContent);\n    }\n\n     // Copy the type utils file\n     const typeUtilsData: TypeUtilsData = { importPath: `./type-utils` };\n     await fs.mkdir(outputTypescriptDirectory, { recursive: true });\n     await fs.writeFile(path.join(outputTypescriptDirectory, './type-utils.ts'), typeUtilsFileContent);\n\n    for (const fullPath of files) {\n        const fileRelativePath = fullPath.replace(path.resolve(inputTzContractDirectory), '');\n        const fileName = fileRelativePath.replace(ext, '');\n        const inputFilePath = path.join(inputTzContractDirectory, fileRelativePath);\n        const typesOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.types.ts`));\n        const codeContentOutputFilePath = path.join(outputTypescriptDirectory, fileRelativePath.replace(ext, `.code.ts`));\n        console.log(`Processing ${fileRelativePath}...`);\n\n        try {\n            const contractTypeName = normalizeContractName(fileName);\n\n            const michelsonCode = await fs.readFile(inputFilePath, { encoding: `utf8` });\n\n            const {\n                typescriptCodeOutput: { typesFileContent, contractCodeFileContent }\n            } = generateContractTypesFromMichelsonCode(michelsonCode, contractTypeName, format, typeAliasData, typeUtilsData);\n\n            // Write output (ensure dir exists)\n            await fs.mkdir(path.dirname(typesOutputFilePath), { recursive: true });\n            await fs.writeFile(typesOutputFilePath, typesFileContent);\n            await fs.writeFile(codeContentOutputFilePath, contractCodeFileContent);\n        } catch (err: unknown) {\n            console.error(`❌ Could not process ${fileRelativePath}`, { err });\n        }\n    }\n};","export const normalizeContractName = (text: string) => text\n    .replace(/[^A-Za-z0-9]/g, '_')\n    .split(\"_\")\n    .filter(x => x)\n    .map(x => x[0].toUpperCase() + x.substring(1))\n    .join('');\n","import * as M from '@taquito/michel-codec';\nimport { GenerateApiError } from './common';\nimport { parseContractStorage, parseContractParameter } from './contract-parser';\nimport { SchemaOutput, toSchema } from './schema-output';\nimport { TypescriptCodeOutput, toTypescriptCode, TypeAliasData, TypeUtilsData } from './typescript-output';\n\nconst parseContractWithMinimalProtocolLevel = (contractScript: string, format: 'tz' | 'json', contractLevelIndex: number): { contract: M.MichelsonContract, protocol: { name: string, key: string } } => {\n    const contractLevels = [\n        { name: 'PsDELPH1', key: M.Protocol.PsDELPH1 },\n        { name: 'PtEdo2Zk', key: M.Protocol.PtEdo2Zk },\n        { name: 'PsFLorena', key: M.Protocol.PsFLorena },\n    ];\n\n    const protocol = contractLevels[contractLevelIndex];\n    if (!protocol) {\n        throw new GenerateApiError(`Could not parse contract script`, contractScript);\n    }\n\n    const p = new M.Parser({ protocol: protocol.key });\n\n    try {\n        const contract = (format === 'tz' ? p.parseScript(contractScript) : p.parseJSON(JSON.parse(contractScript))) as M.MichelsonContract;\n        if (contract) {\n            return {\n                contract,\n                protocol,\n            };\n        }\n    } catch {\n        // Ignore parse errors\n    }\n\n    // Try again with next level\n    return parseContractWithMinimalProtocolLevel(contractScript, format, contractLevelIndex + 1);\n};\n\nexport const generateContractTypesFromMichelsonCode = (contractScript: string, contractName: string, format: 'tz' | 'json', typeAliasData: TypeAliasData, typeUtilsData: TypeUtilsData): {\n    schema: SchemaOutput;\n    typescriptCodeOutput: TypescriptCodeOutput;\n    parsedContract: M.MichelsonContract;\n    minimalProtocol: string;\n} => {\n\n    const p = new M.Parser({ protocol: M.Protocol.PsFLorena });\n\n    const { contract, protocol } = parseContractWithMinimalProtocolLevel(contractScript, format, 0);\n\n    const contractStorage = contract.find(x => x.prim === `storage`) as undefined | M.MichelsonContractStorage;\n    const contractParameter = contract.find(x => x.prim === `parameter`) as undefined | M.MichelsonContractParameter;\n\n    const storageResult = contractStorage && parseContractStorage(contractStorage);\n    const storage = storageResult ?? { storage: { kind: `object`, raw: { prim: `never` } as M.MichelsonType, fields: [] } };\n\n    const parameterResult = contractParameter && parseContractParameter(contractParameter);\n    const methods = parameterResult?.methods ?? [];\n    const schemaOutput = toSchema(methods);\n\n    const typescriptCode = toTypescriptCode(storage, methods, contractName, contract, protocol, typeAliasData, typeUtilsData);\n\n    return {\n        schema: schemaOutput,\n        typescriptCodeOutput: typescriptCode,\n        parsedContract: contract,\n        minimalProtocol: protocol.key,\n    };\n};\n","\nexport class GenerateApiError implements Error {\n    name = `GenerateApiError`;\n    constructor(public message: string, readonly data: unknown) {\n        console.error(`❌ GenerateApiError: ${message}`, data);\n    }\n}\n\nexport const assertExhaustive = (value: never, message: string): void => {\n    console.error(message, { value });\n};\n\nexport const reduceFlatMap = <T>(out: T[], x: T[]): T[] => {\n    out.push(...x);\n    return out;\n}\n\n// const reduceFlatMapTest = () => {\n//     const items = [['a'], ['b']];\n//     const itemsFlat = items.reduce(reduceFlatMap);\n// };\n","import * as M from '@taquito/michel-codec';\nimport { assertExhaustive, GenerateApiError, reduceFlatMap } from './common';\n\nexport type TypedStorage = {\n    storage: {\n        kind: 'object';\n        raw: M.MichelsonType;\n        fields: TypedVar[];\n    };\n};\nexport type TypedParameter = {\n    methods: TypedMethod[];\n};\nexport type TypedMethod = {\n    name: string;\n    args: TypedVar[];\n};\nexport type TypedVar = {\n    name?: string;\n    type: TypedType;\n};\nexport type TypedType = {\n    raw: M.MichelsonType;\n    optional?: boolean;\n} & (\n        {\n            kind: 'unit';\n        } | {\n            kind: 'never';\n        } | {\n            kind: 'unknown';\n        } | {\n            kind: 'value';\n            value: string;\n            typescriptType: 'string' | 'boolean' | 'number' | 'Date';\n        } | {\n            kind: 'union';\n            union: TypedVar[];\n        } | {\n            kind: 'object';\n            fields: TypedVar[];\n        } | {\n            kind: 'array';\n            array: { item: TypedType };\n        } | {\n            kind: 'map';\n            map: { key: TypedType, value: TypedType, isBigMap: boolean };\n        }\n    );\n\nconst toDebugSource = (node: M.MichelsonType) => {\n    return JSON.stringify(node);\n};\n\nexport const parseContractStorage = (storage: M.MichelsonContractStorage): TypedStorage => {\n    const fields = storage.args\n        .map(x => visitVar(x))\n        .reduce(reduceFlatMap, []);\n\n    const fieldsSimple = fields.length === 1 && !fields[0].name && fields[0].type.kind === 'object' ? fields[0].type.fields : fields;\n\n    return {\n        storage: {\n            kind: `object`,\n            raw: storage as unknown as M.MichelsonType,\n            fields: fieldsSimple,\n        },\n    };\n};\n\nexport const parseContractParameter = (parameter: M.MichelsonContractParameter): TypedParameter => {\n    return {\n        methods: parameter.args\n            .map(x => visitContractParameterEndpoint(x as MMethod))\n            .reduce(reduceFlatMap, []),\n    };\n};\n\n\ntype MMethod = M.MichelsonTypeOr<[M.MichelsonType, M.MichelsonType]>;\nconst visitContractParameterEndpoint = (node: MMethod): TypedMethod[] => {\n\n    // console.log('visitContractParameterEndpoint', { node });\n\n    // Sub endpoints (i.e. admin endpoints that are imported)\n    if (node.prim === `or`) {\n        return node.args.map(x => visitContractParameterEndpoint(x as MMethod)).reduce(reduceFlatMap, []);\n    }\n\n    // Sub endpoints as a list with a single or (i.e. admin endpoints that are imported)\n    if (node.prim === `list` && node.args.length as number === 1 && (node.args[0] as MMethod)?.prim === `or`) {\n        return node.args.map(x => visitContractParameterEndpoint(x as MMethod)).reduce(reduceFlatMap, []);\n    }\n\n    const nameRaw = node.annots?.[0];\n    const name = nameRaw?.startsWith('%') ? nameRaw.substr(1) : null;\n\n    if (!name) {\n        console.warn(`Unknown method: ${node.prim as string}`, { node, args: node.args });\n        return [];\n    }\n\n    const nodeType = visitType(node, { ignorePairName: node.prim === 'pair' });\n\n    // Method args are usually objects\n    if (nodeType.kind === 'object') {\n        return [{ name, args: nodeType.fields }];\n    }\n\n    // Simple methods can have a single unnamed argument\n    return [{\n        name,\n        args: [{ type: nodeType }],\n    }];\n};\n\n// type PrimOf<T extends M.MichelsonType> = T extends { prim: infer U } ? U : never;\n// type WithPrim<T extends M.MichelsonType, P extends PrimOf<T>> = T extends { prim: P } ? T : never;\n// const isPrimType = <TPrim extends PrimOf<M.MichelsonType>>(node: undefined | null | M.MichelsonType, prim: TPrim): node is WithPrim<M.MichelsonType, TPrim> => {\n//     return (node && 'prim' in node && node.prim === prim) || false;\n// };\n\ntype MVarArgs = M.MichelsonType;\nconst visitVar = (node: MVarArgs): TypedVar[] => {\n    const name = `annots` in node && node.annots?.length === 1 ? node.annots[0].substr(1) : undefined;\n    const type = visitType(node);\n\n    return [{\n        name,\n        type,\n    }];\n};\n\ntype MType = M.MichelsonType;\nconst visitType = (node: MType, options?: { ignorePairName?: boolean }): TypedType => {\n    // console.log('visitType', { node });\n    // const debug_source = toDebugSource(node);\n\n    // if (typeof node === `string`) {\n    //     return { kind: `value`, raw: node, value: node, typescriptType: `string` };\n    // }\n\n    if (!(`prim` in node)) {\n        // Unknown\n        console.error(`visitType no prim`, { node });\n        return { kind: `unknown`, raw: node };\n    }\n\n    // Union\n    if (node.prim === `or`) {\n        const unionVars = node.args.map(x => visitVar(x)).reduce(reduceFlatMap, []).map(x => x);\n\n        // Flatten with child unions\n        const union = unionVars.map(x => !x.name && x.type.kind === 'union' ? x.type.union : [x]).reduce(reduceFlatMap, []);\n        // const union = unionVars.map(x=>x.type);\n\n        // const union = unionVars.map(x => x.type);\n\n        // Flatten with child unions\n\n        // const rightSide = union[1];\n        // if (rightSide.kind === `union`) {\n        //     union.pop();\n        //     union.push(...rightSide.union);\n        // }\n\n        if (union.some(x => !x)) {\n            throw new GenerateApiError(`or: Some fields are null`, { node });\n        }\n        return {\n            kind: `union`,\n            raw: node,\n            union,\n        };\n    }\n\n    // Intersect\n    if (node.prim === `pair`) {\n        const fields = node.args.map(x => visitVar(x)).reduce(reduceFlatMap, []);\n        if (fields.some(x => !x)) {\n            throw new GenerateApiError(`pair: Some fields are null`, { node, args: node.args, fields });\n        }\n        if (fields.length !== 2) {\n            throw new GenerateApiError(`pair: Expected 2 items`, { node, length: fields.length, fields });\n        }\n\n        // Flatten with unnamed child pairs\n        const fieldsFlat = fields.map(x => (!x.name || options?.ignorePairName) && x.type.kind === 'object' ? x.type.fields : [x]).reduce(reduceFlatMap, []);\n\n        return {\n            kind: `object`,\n            raw: node,\n            fields: fieldsFlat,\n        };\n    }\n\n    // list\n    if (node.prim === `list`\n        || node.prim === `set`\n    ) {\n        if (node.args.length !== 1) {\n            throw new GenerateApiError(`list does not have 1 arg`, { node, args: node.args });\n        }\n\n        const arrayItem = visitType(node.args[0]);\n        if (!arrayItem) {\n            throw new GenerateApiError(`arrayItem are null`, { node, args: node.args, arrayItem });\n        }\n        return {\n            kind: `array`,\n            raw: node,\n            array: { item: arrayItem },\n        };\n    }\n\n    // map\n    if (node.prim === `map`\n        || node.prim === `big_map`\n    ) {\n        if (node.args.length !== 2) {\n            throw new GenerateApiError(`map does not have 2 args`, { node, args: node.args });\n        }\n\n        const mapKey = visitType(node.args[0]);\n        const mapValue = visitType(node.args[1]);\n        if (!mapKey || !mapValue) {\n            throw new GenerateApiError(`map is missing key or value`, { node, args: node.args, mapKey, mapValue });\n        }\n        return {\n            kind: `map`,\n            raw: node,\n            map: {\n                key: mapKey,\n                value: mapValue,\n                isBigMap: node.prim === `big_map`,\n            },\n        };\n    }\n\n    // option\n    if (node.prim === `option`) {\n        return {\n            ...visitType(node.args[0]),\n            optional: true,\n        };\n    }\n\n    // boolean\n    if (node.prim === `bool`) {\n        return {\n            kind: `value`,\n            raw: node,\n            value: node.prim,\n            typescriptType: `boolean`,\n        };\n    }\n\n    // numbers\n    if (node.prim === `nat`\n        || node.prim === `int`\n        || node.prim === `mutez`\n    ) {\n        return {\n            kind: `value`,\n            raw: node,\n            value: node.prim,\n            typescriptType: `number`,\n        };\n    }\n\n    // Date\n    if (node.prim === `timestamp`\n\n    ) {\n        return {\n            kind: `value`,\n            raw: node,\n            value: node.prim,\n            typescriptType: `Date`,\n        };\n    }\n\n    // strings\n    if (node.prim === `address`\n        || node.prim === `key`\n        || node.prim === `key_hash`\n        || node.prim === `chain_id`\n        || node.prim === `string`\n        || node.prim === `signature`\n        || node.prim === `ticket`\n        || node.prim === `bls12_381_fr`\n        || node.prim === `bls12_381_g1`\n        || node.prim === `bls12_381_g2`\n        || node.prim === `sapling_state`\n        || node.prim === `sapling_transaction`\n        || node.prim === `contract`\n    ) {\n        return {\n            kind: `value`,\n            raw: node,\n            value: node.prim,\n            typescriptType: `string`,\n        };\n    }\n\n\n    // void\n    if (node.prim === `unit`) {\n        return {\n            kind: `unit`,\n            raw: node,\n        };\n    }\n\n    // bytes?\n    if (node.prim === `bytes`) {\n        return {\n            kind: `value`,\n            raw: node,\n            value: node.prim,\n            typescriptType: `string`,\n        };\n    }\n\n    // misc?\n    if (node.prim === `lambda`\n        || node.prim === `operation`\n    ) {\n        return {\n            kind: `value`,\n            raw: node,\n            value: node.prim,\n            typescriptType: `string`,\n        };\n    }\n\n    // chest\n    if(node.prim === 'chest'){\n        throw new Error('Not Implemented: chest');\n    }\n    if(node.prim === 'chest_key'){\n        throw new Error('Not Implemented: chest_key');\n    }\n\n    // never\n    if (node.prim === `never`\n    ) {\n        return {\n            kind: `never`,\n            raw: node,\n        };\n    }\n\n\n    // Unknown\n    assertExhaustive(node, `Unknown type`);\n    throw new GenerateApiError(`Unknown type`, { node });\n};\n","import { GenerateApiError } from './common';\nimport { TypedMethod, TypedVar, TypedType } from './contract-parser';\n\ntype SchemaObjectType = { [name: string]: SchemaType };\ntype SchemaType = string | SchemaType[] | SchemaObjectType;\ntype SchemaMethods = {\n    [name: string]: {\n        params: SchemaType;\n    };\n};\nexport type SchemaOutput = {\n    schemaMethods: SchemaMethods;\n};\n\nexport const toSchema = (methods: TypedMethod[]): SchemaOutput => {\n\n    const getSchemaObjectType = (vars: TypedVar[]) => {\n        // console.log('getSchemaObjectType', { vars });\n\n        if (vars.some(x => !x)) {\n            throw new GenerateApiError(`getSchemaObjectType has null vars`, { vars });\n        }\n\n        return vars.reduce((out, x, i) => {\n            out[x.name ?? i] = getSchemaType(x.type);\n            return out;\n        }, {} as SchemaObjectType);\n    };\n\n    const getSchemaType = (t: TypedType): SchemaType => {\n        // console.log('getSchemaType', { t });\n\n        return (t.kind === `value` && t.value ? t.value : null)\n            ?? (t.kind === `array` && t.array ? [getSchemaType(t.array.item)] : null)\n            ?? (t.kind === `map` && t.map ? [`map`, getSchemaType(t.map.key), getSchemaType(t.map.value)] : null)\n            ?? (t.kind === `object` && t.fields ? getSchemaObjectType(t.fields) : null)\n            ?? (t.kind === `unit` ? `unit` : null)\n            ?? (t.kind === `never` ? `never` : null)\n            ?? `${t.raw as unknown as string}`;\n    };\n\n    const schemaMethods = methods.reduce((out, x) => {\n        // console.log('schemaMethods', { x });\n\n        out[x.name] = {\n            params: x.args.length === 1 && !x.args[0].name ? getSchemaType(x.args[0].type) : getSchemaObjectType(x.args ?? []),\n        };\n        return out;\n    }, {} as SchemaMethods);\n\n    return {\n        schemaMethods,\n    };\n};\n","import { assertExhaustive, GenerateApiError, reduceFlatMap } from './common';\nimport { TypedStorage, TypedMethod, TypedType, TypedVar } from './contract-parser';\n\nexport type TypescriptCodeOutput = {\n    typesFileContent: string;\n    contractCodeFileContent: string;\n    storage: string;\n    methods: string;\n    methodsObject: string;\n};\n\nexport type TypeAliasData = {\n    mode: 'local',\n    fileContent?: string,\n} | {\n    mode: 'file' | 'library',\n    importPath?: string,\n} | {\n    mode: 'simple',\n};\nexport type TypeUtilsData = {\n    importPath: string,\n};\n\nexport const toTypescriptCode = (storage: TypedStorage, methods: TypedMethod[], contractName: string, parsedContract: unknown, protocol: { name: string, key: string }, typeAliasData: TypeAliasData, typeUtilsData: TypeUtilsData): TypescriptCodeOutput => {\n    type TypeAlias = { aliasType: string, simpleTypeDefinition: string, simpleTypeImports?: { name: string, isDefault?: boolean, from: string }[] };\n    const usedStrictTypes = [] as TypeAlias[];\n    const addTypeAlias = (strictType: TypeAlias) => {\n        if (!usedStrictTypes.some(x => x.aliasType === strictType.aliasType)) {\n            usedStrictTypes.push(strictType);\n        }\n    };\n\n    // Not really tabs :)\n    const tabs = (indent: number) => Array(indent).fill(`    `).join(``);\n    const toIndentedItems = (indent: number, delimeters: { afterItem?: string, beforeItem?: string }, items: string[]) => {\n        return `\n${tabs(indent + 1)}${items.join(`${delimeters.afterItem ?? ``}\n${tabs(indent + 1)}${delimeters.beforeItem ?? ``}`)}\n${tabs(indent)}`;\n    };\n\n    const typeToCode = (t: TypedType, indent: number): string => {\n        if (t.kind === `value`) {\n            // return `${t.typescriptType}`;\n\n            const prim = `prim` in t.raw ? t.raw.prim : `unknown`;\n\n            // Strict mode\n            if (t.typescriptType === `boolean`\n                || t.typescriptType === `string` && prim === `string`\n            ) {\n                return `${t.typescriptType}`;\n            }\n\n            if (t.typescriptType === 'number') {\n                const simpleBaseType = `string | BigNumber | number`;\n                const typeAlias: TypeAlias = { aliasType: prim, simpleTypeDefinition: `type ${prim} = ${simpleBaseType};`, simpleTypeImports: [{ name: 'BigNumber', isDefault: true, from: 'bignumber.js' }] };\n                addTypeAlias(typeAlias);\n\n                return typeAlias.aliasType;\n            }\n\n            const simpleBaseType = t.typescriptType === 'Date' ? 'Date | string' : t.typescriptType;\n            const typeAlias: TypeAlias = { aliasType: prim, simpleTypeDefinition: `type ${prim} = ${simpleBaseType};` };\n            addTypeAlias(typeAlias);\n\n            return typeAlias.aliasType;\n        }\n        if (t.kind === `array`) {\n            return `Array<${typeToCode(t.array.item, indent)}>`;\n        }\n        if (t.kind === `map`) {\n\n            const typeAlias: TypeAlias = t.map.isBigMap\n                ? { aliasType: `BigMap`, simpleTypeDefinition: 'type BigMap<K, T> = MichelsonMap<K, T>;', simpleTypeImports: [{ name: 'MichelsonMap', from: '@taquito/taquito' }] }\n                : { aliasType: `MMap`, simpleTypeDefinition: 'type MMap<K, T> = MichelsonMap<K, T>;', simpleTypeImports: [{ name: 'MichelsonMap', from: '@taquito/taquito' }] };\n            addTypeAlias(typeAlias);\n\n            return `${typeAlias.aliasType}<${typeToCode(t.map.key, indent)}, ${typeToCode(t.map.value, indent)}>`;\n        }\n        if (t.kind === `object`) {\n            return `{${toIndentedItems(indent, {},\n                t.fields.map((a, i) => varToCode(a, i, indent + 1) + `;`),\n            )}}`;\n        }\n        if (t.kind === `union`) {\n\n            const getUnionItem = (a: TypedVar, i: number) => {\n                const itemCode = `${varToCode(a, i, indent + 1)}`;\n\n                // Keep on single line if already on single line\n                if (!itemCode.includes(`\\n`)) {\n                    return `{ ${itemCode} }`;\n                }\n\n                // Indent if multi-line (and remake with extra indent)\n                return `{${toIndentedItems(indent + 1, {}, [`${varToCode(a, i, indent + 2)}`])}}`;\n            };\n\n            return `(${toIndentedItems(indent, { beforeItem: `| ` },\n                t.union.map(getUnionItem),\n            )})`;\n        }\n        if (t.kind === `unit`) {\n            const typeAlias: TypeAlias = { aliasType: `unit`, simpleTypeDefinition: `type unit = (true | undefined);`, };\n            addTypeAlias(typeAlias);\n            return typeAlias.aliasType;\n        }\n        if (t.kind === `never`) {\n            return `never`;\n        }\n        if (t.kind === `unknown`) {\n            return `unknown`;\n        }\n\n        assertExhaustive(t, `Unknown type`);\n        throw new GenerateApiError(`Unknown type node`, { t });\n    };\n\n    const varToCode = (t: TypedVar, i: number, indent: number): string => {\n        return `${t.name ?? i}${t.type.optional ? `?` : ``}: ${typeToCode(t.type, indent)}`;\n    };\n\n    const argsToCode = (args: TypedVar[], indent: number, asObject: boolean): string => {\n        if (args.length === 1) {\n            if (args[0].type.kind === `unit`) { return ``; }\n            return `${args[0].name ?? `param`}: ${typeToCode(args[0].type, indent + 1)}`;\n        }\n\n        const result = `${toIndentedItems(indent, {},\n            args.filter(x => x.name || x.type.kind !== `unit`).map((a, i) => varToCode(a, i, indent + 1) + `,`),\n        )}`;\n\n        if(asObject){\n            return `params: {${result}}`;\n        }\n\n        return result;\n    };\n\n    const methodsToCode = (indent: number) => {\n        const methodFields = methods.map(x => {\n            const methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, false)}) => Promise<void>;`;\n            return methodCode;\n        });\n\n        const methodsTypeCode = `type Methods = {${toIndentedItems(indent, {}, methodFields)}};`;\n        return methodsTypeCode;\n    };\n    const methodsObjectToCode = (indent: number) => {\n        const methodFields = methods.map(x => {\n            const methodCode = `${x.name}: (${argsToCode(x.args, indent + 1, true)}) => Promise<void>;`;\n            return methodCode;\n        });\n\n        const methodsTypeCode = `type MethodsObject = {${toIndentedItems(indent, {}, methodFields)}};`;\n        return methodsTypeCode;\n    };\n\n    const storageToCode = (indent: number) => {\n        const storageTypeCode = `type Storage = ${typeToCode(storage.storage, indent)};`;\n        return storageTypeCode;\n    };\n\n    const methodsCode = methodsToCode(0);\n    const methodsObjectCode = methodsObjectToCode(0);\n    const storageCode = storageToCode(0);\n\n    // Simple type aliases\n    const simpleTypeMappingImportsAll = new Map(usedStrictTypes.map(x => x.simpleTypeImports ?? []).reduce(reduceFlatMap, []).map(x => [`${x?.from}:${x?.name}:${x?.isDefault}`, x]));\n    const simpleTypeMappingImportsFrom = [...simpleTypeMappingImportsAll.values()].reduce((out, x) => {\n        const entry = out[x.from] ?? (out[x.from] = { names: [] });\n        if (x.isDefault) {\n            entry.default = x.name;\n        } else {\n            entry.names.push(x.name);\n        }\n        entry.names.sort((a, b) => a.localeCompare(b));\n        return out;\n    }, {} as { [from: string]: { names: string[], default?: string } });\n\n    const simpleTypeMappingImportsText = Object.keys(simpleTypeMappingImportsFrom)\n        .map(k => {\n            const entry = simpleTypeMappingImportsFrom[k];\n            const items = [entry.default, entry.names.length ? `{ ${entry.names.join(', ')} }` : ''].filter(x => x);\n            return `import ${items.join(', ')} from '${k}';\\n`;\n        })\n        .join('');\n\n    const simpleTypeMapping = usedStrictTypes\n        .sort((a, b) => a.aliasType.localeCompare(b.aliasType))\n        .map(x => x.simpleTypeDefinition).join(`\\n`);\n\n    const typeUtilsDefinitions =\n            `import { ContractAbstractionFromContractType, WalletContractAbstractionFromContractType } from '${typeUtilsData.importPath}';`;\n\n    const typeAliasesDefinitions =\n        typeAliasData.mode === 'simple' ? `${simpleTypeMappingImportsText}${simpleTypeMapping}`\n            : typeAliasData.mode === 'local' ? typeAliasData.fileContent\n                : `import { ${usedStrictTypes.map(x => x.aliasType).join(`, `)} } from '${typeAliasData.importPath}';`;\n\n    const contractTypeName = `${contractName}ContractType`;\n    const walletTypeName = `${contractName}WalletType`;\n    const codeName = `${contractName}Code`;\n\n    const typesFileContent = `\n${typeUtilsDefinitions}\n${typeAliasesDefinitions}\n\n${storageCode}\n\n${methodsCode}\n\n${methodsObjectCode}\n\ntype contractTypes = { methods: Methods, methodsObject: MethodsObject, storage: Storage, code: { __type: '${codeName}', protocol: string, code: object[] } };\nexport type ${contractTypeName} = ContractAbstractionFromContractType<contractTypes>;\nexport type ${walletTypeName} = WalletContractAbstractionFromContractType<contractTypes>;\n`;\n\n    const contractCodeFileContent = `\nexport const ${codeName}: { __type: '${codeName}', protocol: string, code: object[] } = {\n    __type: '${codeName}',\n    protocol: '${protocol.key}',\n    code: JSON.parse(\\`${JSON.stringify(parsedContract)}\\`)\n};\n`;\n    return {\n        typesFileContent,\n        contractCodeFileContent,\n        storage: storageCode,\n        methods: methodsCode,\n        methodsObject: methodsObjectCode,\n    };\n\n};\n\n\n","// This is required for copying the type aliases to a local file\nexport const typeAliasesFileContent = `\nimport { BigNumber } from 'bignumber.js';\nimport { MichelsonMap } from '@taquito/taquito';\n\nexport type unit = (true | undefined) & { __type: 'unit' };\n\nexport type address = string & { __type: 'address' };\nexport type bytes = string & { __type: 'bytes' };\nexport type contract = string & { __type: 'contract' };\nexport type operation = string & { __type: 'operation' };\nexport type key = string & { __type: 'key' };\nexport type key_hash = string & { __type: 'key_hash' };\nexport type signature = string & { __type: 'signature' };\nexport type ticket = string & { __type: 'ticket' };\n\nexport type timestamp = string & { __type: 'timestamp' };\n\nexport type int = BigNumber & { __type: 'int' };\nexport type nat = BigNumber & { __type: 'nat' };\n\nexport type mutez = BigNumber & { __type: 'mutez' };\nexport type tez = BigNumber & { __type: 'tez' };\n\nexport type MMap<K, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => V };\nexport type BigMap<K, V> = Omit<MichelsonMap<K, V>, 'get'> & { get: (key: K) => Promise<V> };\n\n\nconst createStringTypeTas = <T extends string>() => {\n    return (value: string): T => value as T;\n};\n\nconst createBigNumberTypeTas = <T extends BigNumber>() => {\n    return (value: number | BigNumber | string): T => new BigNumber(value) as T;\n};\n\ntype asMapParamOf<K, V> = K extends string ? { [key: string]: V } | Array<{ key: K, value: V }>\n    : K extends number ? { [key: number]: V } | Array<{ key: K, value: V }>\n    : Array<{ key: K, value: V }>;\n\nfunction asMap<K, V>(value: asMapParamOf<K, V>): MMap<K, V> {\n    const m = new MichelsonMap<K, V>();\n    if (Array.isArray(value)) {\n        const vArray = value as Array<{ key: K, value: V }>;\n        vArray.forEach(x => m.set(x.key, x.value));\n    } else {\n        const vObject = value as { [key: string]: V };\n        Object.keys(vObject).forEach(key => m.set(key as unknown as K, vObject[key]));\n    }\n    return m as MMap<K, V>;\n}\nconst asBigMap = <K, V>(value: asMapParamOf<K, V>) => asMap(value) as unknown as BigMap<K, V>;\n\nfunction add<T extends BigNumber>(a: T, b: T): T {\n    return a.plus(b) as T;\n}\nfunction subtract<T extends BigNumber>(a: T, b: T): T {\n    return a.minus(b) as T;\n}\n\n/** tas: Tezos 'as' casting for strict types */\nexport const tas = {\n    address: createStringTypeTas<address>(),\n    bytes: createStringTypeTas<bytes>(),\n    contract: createStringTypeTas<contract>(),\n    timestamp: (value: string | Date): timestamp => new Date(value).toISOString() as timestamp,\n\n    int: createBigNumberTypeTas<int>(),\n    nat: createBigNumberTypeTas<nat>(),\n    mutez: createBigNumberTypeTas<mutez>(),\n    tez: createBigNumberTypeTas<tez>(),\n\n    map: asMap,\n    bigMap: asBigMap,\n\n    // Operations\n    add,\n    subtract,\n\n    // To number\n    number: (value: string | BigNumber) => Number(value + ''),\n};\n`;","// This is required for copying the type utils to a local file\nexport const typeUtilsFileContent = `\nimport { ContractAbstraction, ContractMethod, ContractMethodObject, ContractProvider, Wallet } from '@taquito/taquito';\n\ntype BaseContractType = { methods: unknown, methodsObject: unknown, storage: unknown };\n\ntype ContractMethodsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {\n[M in keyof TContract['methods']]:\nTContract['methods'][M] extends (...args: infer A) => unknown\n? (...args: A) => ContractMethod<T>\n: never\n};\ntype ContractMethodsObjectsOf<T extends ContractProvider | Wallet, TContract extends BaseContractType> = {\n[M in keyof TContract['methodsObject']]:\nTContract['methodsObject'][M] extends (...args: infer A) => unknown\n? (...args: A) => ContractMethodObject<T>\n: never\n};\ntype ContractStorageOf<TContract extends BaseContractType> = TContract['storage'];\n\nexport type ContractAbstractionFromContractType<TContract extends BaseContractType> = \n    ContractAbstraction<ContractProvider, \n        ContractMethodsOf<ContractProvider, TContract>,\n        ContractMethodsObjectsOf<ContractProvider, TContract>,\n        {},\n        {},\n        ContractStorageOf<TContract>\n    >;\n\nexport type WalletContractAbstractionFromContractType<TContract extends BaseContractType> = \n    ContractAbstraction<Wallet, \n        ContractMethodsOf<Wallet, TContract>,\n        ContractMethodsObjectsOf<Wallet, TContract>,\n        {},\n        {},\n        ContractStorageOf<TContract>\n    >;\n`;"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"../"}